# 2. 目录结构与关键类（扩展）

本章逐一讲解 kronos-codegen 的核心源码文件，包含设计动机与算法细节。

源码：kronos-codegen/src/main/kotlin/com/kotlinorm/codegen

## ConfigReader.kt

- 全局状态：
  - `var mapper = ObjectMapper(TomlFactory())`
  - `var codeGenConfig: TemplateConfig? = null`
- `fun init(path: String)`
  - 算法：
    1. `val config = readConfig(path)`；支持通过 `extend` 递归合并配置。
    2. 提取 tables（`List<Map<String,String?>>`），进行严格校验；类型不匹配或缺失抛出明确异常。
    3. 提取 `output`、`dataSource`；`strategy` 可选。
    4. 构建 `TemplateConfig`：
       - tables -> `TableConfig(name, className)`。
       - `StrategyConfig` 将字符串映射到 Kronos 策略：
         - `tableNamingStrategy`、`fieldNamingStrategy` 支持 `lineHumpNamingStrategy` 与 `noneNamingStrategy`。
         - `create|update|logicDelete|optimisticLock|primaryKey` -> `KronosCommonStrategy(true, Field(name))`。
       - `OutputConfig(targetDir, packageName, tableCommentLineWords)`。
       - `dataSource = createWrapper(wrapperClassName, initialDataSource(dataSourceConf))`。
    5. 通过日志输出成功信息（绿色），并赋值给全局 `codeGenConfig`。
  - 设计说明：
    - 配置出错快速失败，错误信息可操作。
    - 策略字符串映射保持最小、明确。

- `fun readConfig(path: String): Map<String, Any?>`
  - 算法：
    1. 解析 TOML -> `Map<String, Any?>`。
    2. 当 `config["extend"] != null`：
       - 读取 `extendPath`，输出日志。
       - 解析 `extendConfig`。
       - 合并：`config = extendConfig + config`（子覆盖父）。
    3. 返回最终 Map。
  - 保证：支持多级继承；就近覆盖。

## TemplateConfig.kt

- 维护生成上下文，并绑定 Kronos 全局策略。
- 关键字段：
  - `table: List<TableConfig>` 与派生延迟属性：`tableNames`、`classNames`、`tableComments`、`fields`、`indexes`。
  - `output: OutputConfig` -> `targetDir`、`packageName`、`tableCommentLineWords`。
  - `dataSource: KronosDataSourceWrapper` 暴露为 `wrapper`。
- init：
  - `Kronos.init { ... }` 设置命名与通用策略；未提供则保留默认。
  - `Kronos.dataSource = { wrapper }` 向全局暴露数据源包装。
  - 包名推断：若未显式提供，则从 `targetDir` 中 `main/kotlin/` 之后的片段推断；否则回退 `com.kotlinorm.orm.table`。
- 懒加载：
  - `tableComments` -> `queryTableComment(name, wrapper)`。
  - `fields` -> `SqlManager.getTableColumns(wrapper, name)`。
  - `indexes` -> `SqlManager.getTableIndexes(wrapper, name)`。
- 模板 API：
  - `companion object fun template(render: KronosTemplate.() -> Unit): List<KronosConfig>`
    - 确保 `codeGenConfig` 已初始化。
    - 为每张表构建 `KronosTemplate`，渲染，封装为 `KronosConfig(content, "<targetDir>/<className>.kt")`。

## KronosTemplate.kt

- 目标：提供易用的渲染上下文与辅助算法。
- 公开字段：`packageName`、`tableName`、`className`、`tableComment`、`fields`、`indexes`、`imports`、`tableCommentLineWords`。
- 内容拼接：
  - `var content = ""`；`operator fun String?.unaryPlus()` 逐行追加；`fun indent(num: Int)` 返回空格缩进。
- import 管理：
  - `imports` 为 LinkedHashSet，初始包含 `Table` 与 `KPojo`，辅助函数按需追加。
- 算法：
  - `Field.annotations(): List<String>`：
    - 主键判定：若全局 `primaryKeyStrategy.field.columnName == columnName`，则标记 `primaryKey = IDENTITY`。
    - 根据主键类型输出 `@PrimaryKey`；非空且非主键 -> `@Necessary`；存在默认值 -> `@Default("value")`。
    - `@ColumnType` 输出条件：当不属于简单 string/bool/number 且长度/精度有意义时，拼装参数输出。
    - 时间/删除/乐观锁注解：比较字段名与全局策略字段名决定输出。
  - `KTableIndex.toAnnotations()` / `List<KTableIndex>.toAnnotations()`：
    - 组装 `@TableIndex(name, columns, type, method, concurrently)` 字面量字符串。
  - `formatedComment`（lazy）：
    - 空格分词、按 `tableCommentLineWords` 进行换行，前缀 `// `。

## KronosConfig.kt

- 仅承载输出字符串与文件路径。
- `List<KronosConfig>.write()` 算法：确保目录存在；不存在则创建文件；写入文本；记录成功日志。

## DataSourceHelper.kt

- `initialDataSource(config)`：
  - 默认数据源类为 `org.apache.commons.dbcp2.BasicDataSource`；无参构造实例化。
  - 遍历 config（忽略 `dataSourceClassName`/`wrapperClassName`），生成 `setXxx`/`setXXX`/`setxxx` 三种 setter 名称，查找兼容方法（单参数、类型可兼容），通过 `convertValue` 转换后赋值；异常时告警继续。
- `createWrapper(className, dataSource)`：
  - className 为空则使用 `com.kotlinorm.KronosBasicWrapper` 并告警；
  - 优先尝试 `dataSource::class.java` 构造器，找不到则尝试 `javax.sql.DataSource`；
  - 失败抛出 RuntimeException 并包含原始原因。

## Extensions.kt

- `MAX_COMMENT_LINE_WORDS = 80` 为注释换行默认宽度。
- `Field.kotlinType`：将 `KColumnType` 映射到 Kotlin 基础类型（Boolean/Byte/Short/Int/Long/Float/Double/BigDecimal/String/ByteArray/LocalDate/LocalTime/LocalDateTime/Instant/Char/UUID），其余默认 String。