# 4. IR 处理流程

本节基于源码概述编译期的 IR 处理顺序与关键逻辑。

## 4.1 入口：KronosParserExtension.generate

Kotlin 编译器（K2）在生成 IR 阶段回调 IrGenerationExtension：
- 调用 `resetKClassCreator()` 清空缓存；
- 对模块 `moduleFragment` 应用 `KronosParserTransformer`；
- 遍历结束后，回放 `initFunctions`，在收集的上下文中调用 `buildKClassMapper` 生成 KClass 映射；
- 若 `debug` 开启，使用 `dumpKotlinLike` 将每个 IR 文件输出到 `debugInfoPath`。

## 4.2 KronosParserTransformer：核心分发

- visitCall
  - 遍历所有调用，若类型实参中存在 KPojo 子类（`superTypes.any { it.classFqName == KPojoFqName }`），则加入 `kPojoClasses`；
  - 若被调函数带有 `@KronosInit` 注解，则将其函数表达式加入 `initFunctions`，等待编译末尾回放；
  - 对 `TypedQuery` 与 `SelectFrom*` 的调用，执行 `updateTypedQueryParameters(expression)`，修正参数类型；
- visitFunctionNew
  - 根据扩展接收者（`extensionReceiver`）的类型 FQ 名，将函数体委派到对应的 KTable* Transformer：
    - `KTableForSelect` → `KTableParserForSelectTransformer`
    - `KTableForSet` → `KTableParserForSetTransformer`
    - `KTableForCondition` → `KTableParserForConditionTransformer`
    - `KTableForSort` → `KTableParserForSortReturnTransformer`
    - `KTableForReference` → `KTableParserForReferenceTransformer`
- visitClassNew / visitClassReference / visitConstructorCall
  - 收集所有 KPojo 子类以便后续处理。

## 4.3 KTable* 变换的思路

以 `KTableParserForSelectTransformer` 为例：
- 在 return 之前注入一段 IR：`addFieldList(irFunction, expression)`；
- 该工具方法会解析 `it.username.as_("alias")` 等 DSL 写法，将其翻译为内部字段描述的追加；
- 最终既保留了原有表达式的行为，又在编译期收集到查询所需的字段列表。

其它 Transformer 以类似方式替换/增强函数体，完成条件、排序、引用等语义的提前固化。

## 4.4 初始化钩子与映射生成

- `@KronosInit` 注解的函数表达式会在 visitCall 阶段被捕获；
- 编译末尾由 `KClassCreatorUtil.initFunctions` 统一回放，在对应的 `builder` 与 `context` 下调用 `buildKClassMapper`；
- 该步骤将基于已收集的 `kPojoClasses` 生成映射，供运行期或后续阶段使用。
