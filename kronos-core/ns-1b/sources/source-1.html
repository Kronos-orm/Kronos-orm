


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>kronos-core Coverage Report > InsertClause</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: kronos-core<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.kotlinorm.orm.insert</a>
</div>

<h1>Coverage Summary for Class: InsertClause (com.kotlinorm.orm.insert)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">InsertClause</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (8/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    44.1%
  </span>
  <span class="absValue">
    (15/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.8%
  </span>
  <span class="absValue">
    (67/79)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.7%
  </span>
  <span class="absValue">
    (366/471)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InsertClause$Companion</td>
<td class="coverageStat">
  <span class="percent">
    9.1%
  </span>
  <span class="absValue">
    (1/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.1%
  </span>
  <span class="absValue">
    (1/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    10.7%
  </span>
  <span class="absValue">
    (14/131)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InsertClause$WhenMappings</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    40.9%
  </span>
  <span class="absValue">
    (9/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    39.5%
  </span>
  <span class="absValue">
    (15/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75.6%
  </span>
  <span class="absValue">
    (68/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.1%
  </span>
  <span class="absValue">
    (380/602)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright 2022-2025 kronos-orm
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package com.kotlinorm.orm.insert
&nbsp;
&nbsp;import com.kotlinorm.beans.dsl.Field
&nbsp;import com.kotlinorm.beans.dsl.KTableForReference.Companion.afterReference
&nbsp;import com.kotlinorm.beans.generator.SnowflakeIdGenerator
&nbsp;import com.kotlinorm.beans.generator.UUIDGenerator
&nbsp;import com.kotlinorm.beans.generator.customIdGenerator
&nbsp;import com.kotlinorm.beans.task.KronosActionTask
&nbsp;import com.kotlinorm.beans.task.KronosActionTask.Companion.merge
&nbsp;import com.kotlinorm.beans.task.KronosAtomicActionTask
&nbsp;import com.kotlinorm.beans.task.KronosOperationResult
&nbsp;import com.kotlinorm.cache.fieldsMapCache
&nbsp;import com.kotlinorm.cache.insertSqlCache
&nbsp;import com.kotlinorm.cache.kPojoAllColumnsCache
&nbsp;import com.kotlinorm.cache.kPojoCreateTimeCache
&nbsp;import com.kotlinorm.cache.kPojoLogicDeleteCache
&nbsp;import com.kotlinorm.cache.kPojoOptimisticLockCache
&nbsp;import com.kotlinorm.cache.kPojoPrimaryKeyCache
&nbsp;import com.kotlinorm.cache.kPojoUpdateTimeCache
&nbsp;import com.kotlinorm.database.SqlManager.getInsertSql
&nbsp;import com.kotlinorm.enums.KOperationType
&nbsp;import com.kotlinorm.enums.PrimaryKeyType
&nbsp;import com.kotlinorm.exceptions.EmptyFieldsException
&nbsp;import com.kotlinorm.interfaces.KPojo
&nbsp;import com.kotlinorm.interfaces.KronosDataSourceWrapper
&nbsp;import com.kotlinorm.orm.cascade.CascadeInsertClause
&nbsp;import com.kotlinorm.types.ToReference
&nbsp;import com.kotlinorm.utils.DataSourceUtil.orDefault
&nbsp;import com.kotlinorm.utils.execute
&nbsp;import com.kotlinorm.utils.processParams
&nbsp;
<b class="fc">&nbsp;class InsertClause&lt;T : KPojo&gt;(val pojo: T) {</b>
<b class="fc">&nbsp;    private val paramMap = pojo.toDataMap()</b>
<b class="fc">&nbsp;    private val tableName = pojo.kronosTableName()</b>
<b class="fc">&nbsp;    private var kClass = pojo.kClass()</b>
<b class="fc">&nbsp;    private var createTimeStrategy = kPojoCreateTimeCache[kClass]</b>
<b class="fc">&nbsp;    private var updateTimeStrategy = kPojoUpdateTimeCache[kClass]</b>
<b class="fc">&nbsp;    private var logicDeleteStrategy = kPojoLogicDeleteCache[kClass]</b>
<b class="fc">&nbsp;    private var optimisticStrategy = kPojoOptimisticLockCache[kClass]</b>
<b class="fc">&nbsp;    internal var allColumns = kPojoAllColumnsCache[kClass]!!</b>
<b class="fc">&nbsp;    private var cascadeEnabled = true</b>
<b class="fc">&nbsp;    var stash = mutableMapOf&lt;String, Any?&gt;()</b>
&nbsp;
&nbsp;    /**
&nbsp;     * cascadeAllowed
&nbsp;     *
&nbsp;     * Fields that are allowed to use cascade, if not set, all fields are allowed to use cascade
&nbsp;     *
&nbsp;     * 允许级联的字段，若为空则允许所有字段级联
&nbsp;     */
<b class="fc">&nbsp;    internal var cascadeAllowed: Set&lt;Field&gt;? = null</b>
&nbsp;
&nbsp;    fun cascade(enabled: Boolean): InsertClause&lt;T&gt; {
<b class="fc">&nbsp;        cascadeEnabled = enabled</b>
<b class="fc">&nbsp;        return this</b>
&nbsp;    }
&nbsp;
&nbsp;    fun cascade(someFields: ToReference&lt;T, Any?&gt;): InsertClause&lt;T&gt; {
<b class="nc">&nbsp;        someFields ?: throw EmptyFieldsException()</b>
<b class="nc">&nbsp;        cascadeEnabled = true</b>
<b class="nc">&nbsp;        pojo.afterReference {</b>
<b class="nc">&nbsp;            someFields(it)</b>
<b class="nc">&nbsp;            if (fields.isEmpty()) throw EmptyFieldsException()</b>
<b class="nc">&nbsp;            cascadeAllowed = fields.toSet()</b>
&nbsp;        }
<b class="nc">&nbsp;        return this</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    fun build(wrapper: KronosDataSourceWrapper? = null): KronosActionTask {</b>
<b class="fc">&nbsp;        var useIdentity = false</b>
<b class="fc">&nbsp;        val paramMapNew = mutableMapOf&lt;String, Any?&gt;()</b>
<b class="fc">&nbsp;        val fieldsMap = fieldsMapCache[kClass]!!</b>
<b class="fc">&nbsp;        val toInsertFields = mutableListOf&lt;Field&gt;()</b>
<b class="fc">&nbsp;        val primaryKeyField = kPojoPrimaryKeyCache[kClass]!!</b>
<b class="pc">&nbsp;        when (primaryKeyField.primaryKey) {</b>
<b class="nc">&nbsp;            PrimaryKeyType.UUID -&gt; paramMap[primaryKeyField.name] = UUIDGenerator.nextId()</b>
<b class="nc">&nbsp;            PrimaryKeyType.SNOWFLAKE -&gt; paramMap[primaryKeyField.name] = SnowflakeIdGenerator.nextId()</b>
<b class="nc">&nbsp;            PrimaryKeyType.CUSTOM -&gt; paramMap[primaryKeyField.name] = customIdGenerator?.nextId()</b>
<b class="fc">&nbsp;            PrimaryKeyType.IDENTITY -&gt; useIdentity = true</b>
&nbsp;            else -&gt; {}
&nbsp;        }
<b class="pc">&nbsp;        if (paramMap[primaryKeyField.name] != null || primaryKeyField.defaultValue != null) {</b>
<b class="fc">&nbsp;            useIdentity = false</b>
&nbsp;        }
<b class="fc">&nbsp;        stash[&quot;useIdentity&quot;] = useIdentity</b>
<b class="fc">&nbsp;        allColumns.forEach {</b>
<b class="pc">&nbsp;            if (it.defaultValue != null &amp;&amp; paramMap[it.name] == null) {</b>
<b class="fc">&nbsp;                paramMap[it.name] = it.defaultValue</b>
&nbsp;            }
<b class="pc">&nbsp;            if (it.isColumn &amp;&amp; !(it.primaryKey == PrimaryKeyType.IDENTITY &amp;&amp; paramMap[it.name] == null)) {</b>
<b class="fc">&nbsp;                toInsertFields.add(it)</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="pc">&nbsp;        if(useIdentity &amp;&amp; !paramMap.containsKey(primaryKeyField.name)){</b>
<b class="nc">&nbsp;            toInsertFields.remove(primaryKeyField)</b>
&nbsp;        }
&nbsp;        arrayOf(
<b class="fc">&nbsp;            createTimeStrategy to true,</b>
<b class="fc">&nbsp;            updateTimeStrategy to true,</b>
<b class="fc">&nbsp;            logicDeleteStrategy to false,</b>
<b class="fc">&nbsp;            optimisticStrategy to false</b>
<b class="fc">&nbsp;        ).forEach {</b>
<b class="fc">&nbsp;            it.first?.execute(it.second) { field, value -&gt;</b>
<b class="fc">&nbsp;                paramMap[field.name] = value</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        paramMap.forEach { (key, value) -&gt;</b>
<b class="fc">&nbsp;            val field = fieldsMap[key]</b>
<b class="pc">&nbsp;            if (field != null &amp;&amp; value != null) {</b>
<b class="fc">&nbsp;                paramMapNew[key] = processParams(wrapper.orDefault(), field, value)</b>
&nbsp;            } else {
<b class="fc">&nbsp;                paramMapNew[key] = value</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        val sql = insertSqlCache[kClass to useIdentity, {</b>
<b class="fc">&nbsp;            getInsertSql(</b>
<b class="fc">&nbsp;                wrapper.orDefault(),</b>
<b class="fc">&nbsp;                tableName,</b>
<b class="fc">&nbsp;                toInsertFields</b>
<b class="fc">&nbsp;            ).also {</b>
<b class="fc">&nbsp;                insertSqlCache[kClass to useIdentity] = it</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }]
&nbsp;
<b class="fc">&nbsp;        return CascadeInsertClause.build(</b>
<b class="fc">&nbsp;            cascadeEnabled,</b>
<b class="fc">&nbsp;            cascadeAllowed,</b>
<b class="fc">&nbsp;            pojo,</b>
<b class="fc">&nbsp;            KronosAtomicActionTask(</b>
<b class="fc">&nbsp;                sql,</b>
<b class="fc">&nbsp;                paramMapNew,</b>
<b class="fc">&nbsp;                operationType = KOperationType.INSERT,</b>
<b class="fc">&nbsp;                actionInfo = InsertClauseInfo(</b>
<b class="fc">&nbsp;                    kClass,</b>
<b class="fc">&nbsp;                    tableName</b>
&nbsp;                ),
<b class="fc">&nbsp;                stash = stash</b>
&nbsp;            )
&nbsp;        )
&nbsp;
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    fun execute(wrapper: KronosDataSourceWrapper? = null): KronosOperationResult {</b>
<b class="fc">&nbsp;        return build().execute(wrapper)</b>
&nbsp;    }
&nbsp;
&nbsp;    companion object {
&nbsp;        fun &lt;T : KPojo&gt; Iterable&lt;InsertClause&lt;T&gt;&gt;.cascade(
&nbsp;            enabled: Boolean
&nbsp;        ): Iterable&lt;InsertClause&lt;T&gt;&gt; {
<b class="nc">&nbsp;            return this.onEach { it.cascade(enabled) }</b>
&nbsp;        }
&nbsp;
&nbsp;        fun &lt;T : KPojo&gt; Iterable&lt;InsertClause&lt;T&gt;&gt;.cascade(
&nbsp;            someFields: ToReference&lt;T, Any?&gt;
&nbsp;        ): Iterable&lt;InsertClause&lt;T&gt;&gt; {
<b class="nc">&nbsp;            return this.onEach { it.cascade(someFields) }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Builds a KronosActionTask for each InsertClause in the list.
&nbsp;         *
&nbsp;         * This function maps each InsertClause in the Iterable to a KronosActionTask by calling the build function of the InsertClause.
&nbsp;         * It then merges all the KronosActionTasks into a single KronosActionTask using the merge function and returns it.
&nbsp;         *
&nbsp;         * @return KronosActionTask returns a single KronosActionTask that represents the merged tasks for all the InsertClauses in the Iterable.
&nbsp;         */
&nbsp;        fun &lt;T : KPojo&gt; Iterable&lt;InsertClause&lt;T&gt;&gt;.build(): KronosActionTask {
<b class="fc">&nbsp;            return this.map { it.build() }.merge()</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Executes the KronosActionTask built for each InsertClause in the Iterable.
&nbsp;         *
&nbsp;         * This function first builds a KronosActionTask for each InsertClause in the Iterable by calling the build function.
&nbsp;         * It then executes the built KronosActionTask and returns the result.
&nbsp;         *
&nbsp;         * @param wrapper KronosDataSourceWrapper? (optional) the data source wrapper to use for the execution. If not provided, the default data source wrapper is used.
&nbsp;         * @return KronosOperationResult returns the result of the execution of the KronosActionTask.
&nbsp;         */
<b class="nc">&nbsp;        fun &lt;T : KPojo&gt; Iterable&lt;InsertClause&lt;T&gt;&gt;.execute(wrapper: KronosDataSourceWrapper? = null): KronosOperationResult {</b>
<b class="nc">&nbsp;            return build().execute(wrapper)</b>
&nbsp;        }
&nbsp;
&nbsp;        fun &lt;T : KPojo&gt; Array&lt;InsertClause&lt;T&gt;&gt;.cascade(enabled: Boolean): Array&lt;out InsertClause&lt;T&gt;&gt; {
<b class="nc">&nbsp;            return this.onEach { it.cascade(enabled) }</b>
&nbsp;        }
&nbsp;
&nbsp;        fun &lt;T : KPojo&gt; Array&lt;InsertClause&lt;T&gt;&gt;.cascade(someFields: ToReference&lt;T, Any?&gt;): Array&lt;out InsertClause&lt;T&gt;&gt; {
<b class="nc">&nbsp;            return this.onEach { it.cascade(someFields) }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Builds a KronosActionTask for each InsertClause in the Array.
&nbsp;         *
&nbsp;         * This function maps each InsertClause in the Iterable to a KronosActionTask by calling the build function of the InsertClause.
&nbsp;         * It then merges all the KronosActionTasks into a single KronosActionTask using the merge function and returns it.
&nbsp;         *
&nbsp;         * @return KronosActionTask returns a single KronosActionTask that represents the merged tasks for all the InsertClauses in the Iterable.
&nbsp;         */
<b class="nc">&nbsp;        fun &lt;T : KPojo&gt; Array&lt;InsertClause&lt;T&gt;&gt;.build(wrapper: KronosDataSourceWrapper? = null): KronosActionTask {</b>
<b class="nc">&nbsp;            return this.map { it.build(wrapper) }.merge()</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        /**
&nbsp;         * Executes the KronosActionTask built for each InsertClause in the array.
&nbsp;         *
&nbsp;         * This function first builds a KronosActionTask for each InsertClause in the Iterable by calling the build function.
&nbsp;         * It then executes the built KronosActionTask and returns the result.
&nbsp;         *
&nbsp;         * @param wrapper KronosDataSourceWrapper? (optional) the data source wrapper to use for the execution. If not provided, the default data source wrapper is used.
&nbsp;         * @return KronosOperationResult returns the result of the execution of the KronosActionTask.
&nbsp;         */
<b class="nc">&nbsp;        fun &lt;T : KPojo&gt; Array&lt;InsertClause&lt;T&gt;&gt;.execute(wrapper: KronosDataSourceWrapper? = null): KronosOperationResult {</b>
<b class="nc">&nbsp;            return build().execute(wrapper)</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-10-22 15:26</div>
</div>
</body>
</html>
