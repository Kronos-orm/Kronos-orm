


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>kronos-core Coverage Report > SelectFrom</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: kronos-core<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.kotlinorm.orm.join</a>
</div>

<h1>Coverage Summary for Class: SelectFrom (com.kotlinorm.orm.join)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">SelectFrom</td>
<td class="coverageStat">
  <span class="percent">
    38.5%
  </span>
  <span class="absValue">
    (25/65)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.7%
  </span>
  <span class="absValue">
    (49/130)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.5%
  </span>
  <span class="absValue">
    (182/306)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48%
  </span>
  <span class="absValue">
    (1016/2118)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SelectFrom$crossJoin$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SelectFrom$fullJoin$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (34/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SelectFrom$innerJoin$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SelectFrom$leftJoin$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (34/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">SelectFrom$rightJoin$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (34/34)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (28/70)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.7%
  </span>
  <span class="absValue">
    (49/130)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.5%
  </span>
  <span class="absValue">
    (191/321)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48.9%
  </span>
  <span class="absValue">
    (1118/2288)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/**
&nbsp; * Copyright 2022-2025 kronos-orm
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;
&nbsp;package com.kotlinorm.orm.join
&nbsp;
&nbsp;import com.kotlinorm.beans.dsl.Criteria
&nbsp;import com.kotlinorm.beans.dsl.Field
&nbsp;import com.kotlinorm.beans.dsl.KJoinable
&nbsp;import com.kotlinorm.beans.dsl.KSelectable
&nbsp;import com.kotlinorm.beans.dsl.KTableForCondition.Companion.afterFilter
&nbsp;import com.kotlinorm.beans.dsl.KTableForReference.Companion.afterReference
&nbsp;import com.kotlinorm.beans.dsl.KTableForSelect.Companion.afterSelect
&nbsp;import com.kotlinorm.beans.dsl.KTableForSort.Companion.afterSort
&nbsp;import com.kotlinorm.beans.task.KronosAtomicQueryTask
&nbsp;import com.kotlinorm.beans.task.KronosQueryTask
&nbsp;import com.kotlinorm.cache.fieldsMapCache
&nbsp;import com.kotlinorm.cache.kPojoAllColumnsCache
&nbsp;import com.kotlinorm.cache.kPojoLogicDeleteCache
&nbsp;import com.kotlinorm.database.SqlManager.getJoinSql
&nbsp;import com.kotlinorm.database.SqlManager.quote
&nbsp;import com.kotlinorm.enums.JoinType
&nbsp;import com.kotlinorm.enums.KColumnType.CUSTOM_CRITERIA_SQL
&nbsp;import com.kotlinorm.enums.KOperationType
&nbsp;import com.kotlinorm.enums.QueryType
&nbsp;import com.kotlinorm.enums.SortType
&nbsp;import com.kotlinorm.exceptions.EmptyFieldsException
&nbsp;import com.kotlinorm.interfaces.KPojo
&nbsp;import com.kotlinorm.interfaces.KronosDataSourceWrapper
&nbsp;import com.kotlinorm.orm.cascade.CascadeJoinClause
&nbsp;import com.kotlinorm.types.ToFilter
&nbsp;import com.kotlinorm.types.ToReference
&nbsp;import com.kotlinorm.types.ToSelect
&nbsp;import com.kotlinorm.types.ToSort
&nbsp;import com.kotlinorm.utils.ConditionSqlBuilder
&nbsp;import com.kotlinorm.utils.ConditionSqlBuilder.buildConditionSqlWithParams
&nbsp;import com.kotlinorm.utils.DataSourceUtil.orDefault
&nbsp;import com.kotlinorm.utils.Extensions.asSql
&nbsp;import com.kotlinorm.utils.Extensions.eq
&nbsp;import com.kotlinorm.utils.Extensions.toCriteria
&nbsp;import com.kotlinorm.utils.KStack
&nbsp;import com.kotlinorm.utils.execute
&nbsp;import com.kotlinorm.utils.getDefaultBoolean
&nbsp;import com.kotlinorm.utils.logAndReturn
&nbsp;import com.kotlinorm.utils.pop
&nbsp;import com.kotlinorm.utils.processParams
&nbsp;import com.kotlinorm.utils.push
&nbsp;import com.kotlinorm.utils.toLinkedSet
&nbsp;import kotlin.reflect.KClass
&nbsp;
&nbsp;/**
&nbsp; * Select From
&nbsp; *
&nbsp; * Create a joint clause for the given pojos
&nbsp; *
&nbsp; * @param T1 the type of the first pojo
&nbsp; *
&nbsp; * @property t1 the instance of the first pojo
&nbsp; */
<b class="fc">&nbsp;open class SelectFrom&lt;T1 : KPojo&gt;(open val t1: T1) : KSelectable&lt;T1&gt;(t1) {</b>
<b class="nc">&nbsp;    open lateinit var tableName: String</b>
<b class="nc">&nbsp;    open lateinit var paramMap: MutableMap&lt;String, Any?&gt;</b>
<b class="fc">&nbsp;    private var kClass = pojo.kClass()</b>
<b class="fc">&nbsp;    open var logicDeleteStrategy = kPojoLogicDeleteCache[kClass]</b>
<b class="fc">&nbsp;    open var allFields = kPojoAllColumnsCache[kClass]!!</b>
<b class="nc">&nbsp;    open lateinit var listOfPojo: MutableList&lt;Pair&lt;KClass&lt;KPojo&gt;, KPojo&gt;&gt;</b>
&nbsp;    private var condition: Criteria? = null
&nbsp;    private var havingCondition: Criteria? = null
<b class="fc">&nbsp;    override var selectFields: LinkedHashSet&lt;Field&gt; = linkedSetOf()</b>
<b class="fc">&nbsp;    override var selectAll: Boolean = false</b>
<b class="fc">&nbsp;    private var selectFieldsWithNames: MutableMap&lt;String, Field&gt; = mutableMapOf()</b>
<b class="fc">&nbsp;    private var keyCounters: ConditionSqlBuilder.KeyCounter = ConditionSqlBuilder.KeyCounter()</b>
<b class="fc">&nbsp;    val listOfJoinable: MutableList&lt;KJoinable&gt; = mutableListOf()</b>
<b class="fc">&nbsp;    private var groupByFields: LinkedHashSet&lt;Field&gt; = linkedSetOf()</b>
<b class="fc">&nbsp;    private var orderByFields: LinkedHashSet&lt;Pair&lt;Field, SortType&gt;&gt; = linkedSetOf()</b>
&nbsp;    private var distinctEnabled = false
&nbsp;    private var groupEnabled = false
&nbsp;    private var havingEnabled = false
&nbsp;    private var orderEnabled = false
<b class="fc">&nbsp;    override var pageEnabled = false</b>
<b class="fc">&nbsp;    override var limitCapacity = 0</b>
<b class="fc">&nbsp;    private var cascadeEnabled = true</b>
&nbsp;    private var cascadeAllowed: Set&lt;Field&gt;? = null
&nbsp;    private var cascadeSelectedProps: Set&lt;Field&gt;? = null
&nbsp;    private var pi = 0
&nbsp;    private var ps = 0
<b class="fc">&nbsp;    private val databaseOfTable: MutableMap&lt;String, String&gt; = mutableMapOf()</b>
<b class="fc">&nbsp;    internal var operationType = KOperationType.SELECT</b>
&nbsp;
&nbsp;    fun on(on: ToFilter&lt;T1, Boolean?&gt;) {
<b class="pc">&nbsp;        if (null == on) throw EmptyFieldsException()</b>
&nbsp;
<b class="fc">&nbsp;        val criteriaMap = mutableMapOf&lt;String, MutableList&lt;Criteria&gt;&gt;()</b>
<b class="fc">&nbsp;        val constMap = mutableMapOf&lt;String, MutableList&lt;Criteria&gt;&gt;()</b>
<b class="fc">&nbsp;        val repeatList = mutableListOf&lt;Triple&lt;Criteria, String, String&gt;&gt;()</b>
&nbsp;
<b class="fc">&nbsp;        t1.afterFilter {</b>
<b class="fc">&nbsp;            criteriaParamMap = paramMap</b>
<b class="fc">&nbsp;            on(t1)</b>
&nbsp;
<b class="fc">&nbsp;            val stack = KStack&lt;Criteria&gt;()</b>
<b class="fc">&nbsp;            var cur = criteria</b>
<b class="fc">&nbsp;            var prev = criteria</b>
<b class="fc">&nbsp;            while (null != cur || !stack.isEmpty()) {</b>
<b class="fc">&nbsp;                while (null != cur) {</b>
<b class="fc">&nbsp;                    stack.push(cur)</b>
<b class="fc">&nbsp;                    cur = if (cur.children.isNotEmpty()) cur.children.first() else null</b>
&nbsp;                }
<b class="fc">&nbsp;                val top = stack.pop()</b>
<b class="pc">&nbsp;                if (top.children.size &lt;= 1 || top.children[1] == prev) {</b>
<b class="fc">&nbsp;                    prev = top</b>
<b class="fc">&nbsp;                    val topTableName = top.tableName</b>
<b class="pc">&nbsp;                    if (!topTableName.isNullOrEmpty()) {</b>
&nbsp;
<b class="fc">&nbsp;                        val fieldTableName = top.field.tableName</b>
<b class="pc">&nbsp;                        val valueTableName = if (top.value is Field) (top.value as Field).tableName else null</b>
&nbsp;
<b class="pc">&nbsp;                        if (null == valueTableName)</b>
<b class="nc">&nbsp;                            setInMap(top, fieldTableName, constMap)</b>
<b class="pc">&nbsp;                        else if (valueTableName == tableName || (fieldTableName != tableName &amp;&amp; !criteriaMap.contains(</b>
&nbsp;                                fieldTableName
<b class="nc">&nbsp;                            ) &amp;&amp; criteriaMap.contains(valueTableName))</b>
&nbsp;                        ) //value侧为主表或目前field侧无条件而value侧有条件，直接将条件放入field侧
<b class="fc">&nbsp;                            setInMap(top, fieldTableName, criteriaMap)</b>
<b class="pc">&nbsp;                        else if (fieldTableName == tableName || (valueTableName != tableName &amp;&amp; criteriaMap.contains(</b>
&nbsp;                                fieldTableName
&nbsp;                            ))
&nbsp;                        ) //field侧为主表或目前value侧无条件而field侧有条件或两侧都有条件，可直接将条件放入vaule侧
<b class="fc">&nbsp;                            setInMap(top, valueTableName, criteriaMap)</b>
&nbsp;                        else { // 条件两侧均未出现过，将条件放入两侧，后期再根据两端条件数量删除一侧
<b class="nc">&nbsp;                            setInMap(top, valueTableName, criteriaMap)</b>
<b class="nc">&nbsp;                            setInMap(top, fieldTableName, criteriaMap)</b>
<b class="nc">&nbsp;                            repeatList.add(Triple(top, fieldTableName, valueTableName))</b>
&nbsp;                        }
&nbsp;
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (stack.isNotEmpty()) stack.pop()</b>
<b class="fc">&nbsp;                } else cur = top.children[1]</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            repeatList.forEach {</b>
<b class="nc">&nbsp;                val (repeatCriteria, fieldTableName, valueTableName) = it</b>
<b class="nc">&nbsp;                if (null != criteriaMap[fieldTableName] &amp;&amp; criteriaMap[fieldTableName]!!.size == 1)</b>
<b class="nc">&nbsp;                    removeInMap(repeatCriteria, valueTableName, criteriaMap)</b>
<b class="nc">&nbsp;                else removeInMap(repeatCriteria, fieldTableName, criteriaMap)</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="fc">&nbsp;            criteriaMap.putAll(constMap)</b>
<b class="fc">&nbsp;            criteriaMap.keys.forEach { tableName -&gt;</b>
<b class="fc">&nbsp;                val (kClass, kPojo) = listOfPojo.first { it.second.kronosTableName() == tableName }</b>
<b class="fc">&nbsp;                listOfJoinable.add(</b>
<b class="fc">&nbsp;                    KJoinable(</b>
<b class="fc">&nbsp;                        tableName,</b>
<b class="fc">&nbsp;                        JoinType.LEFT_JOIN,</b>
<b class="fc">&nbsp;                        criteriaMap[tableName]!!.toCriteria(),</b>
<b class="fc">&nbsp;                        kClass,</b>
<b class="fc">&nbsp;                        kPojo</b>
&nbsp;                    )
&nbsp;                )
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private fun setInMap(
&nbsp;        criteria: Criteria,
&nbsp;        criteriaTableName: String,
&nbsp;        map: MutableMap&lt;String, MutableList&lt;Criteria&gt;&gt;
&nbsp;    ) {
<b class="fc">&nbsp;        val criteriaList = map.getOrDefault(criteriaTableName, mutableListOf())</b>
<b class="fc">&nbsp;        criteriaList.add(criteria)</b>
<b class="fc">&nbsp;        map[criteriaTableName] = criteriaList</b>
&nbsp;    }
&nbsp;
&nbsp;    private fun removeInMap(
&nbsp;        criteria: Criteria,
&nbsp;        criteriaTableName: String,
&nbsp;        map: MutableMap&lt;String, MutableList&lt;Criteria&gt;&gt;
&nbsp;    ) {
<b class="nc">&nbsp;        val criteriaList = map[criteriaTableName]!!</b>
<b class="nc">&nbsp;        criteriaList.remove(criteria)</b>
<b class="nc">&nbsp;        map[criteriaTableName] = criteriaList</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs a left join operation between two tables.
&nbsp;     *
&nbsp;     * @param another The table to join with.
&nbsp;     * @param on The condition for the join.
&nbsp;     * @throws EmptyFieldsException If the `on` parameter is null.
&nbsp;     */
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
&nbsp;    inline fun &lt;reified T : KPojo&gt; leftJoin(another: T, noinline on: ToFilter&lt;T1, Boolean?&gt;) {
<b class="pc">&nbsp;        if (null == on) throw EmptyFieldsException()</b>
<b class="fc">&nbsp;        val tableName = another.kronosTableName()</b>
<b class="fc">&nbsp;        t1.afterFilter {</b>
<b class="fc">&nbsp;            criteriaParamMap = paramMap</b>
<b class="fc">&nbsp;            on(t1)</b>
<b class="fc">&nbsp;            listOfJoinable.add(KJoinable(tableName, JoinType.LEFT_JOIN, criteria, T::class as KClass&lt;KPojo&gt;, another))</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs a right join operation between two tables.
&nbsp;     *
&nbsp;     * @param another The table to join with.
&nbsp;     * @param on The condition for the join.
&nbsp;     * @throws EmptyFieldsException If the `on` parameter is null.
&nbsp;     */
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
&nbsp;    inline fun &lt;reified T : KPojo&gt; rightJoin(another: T, noinline on: ToFilter&lt;T1, Boolean?&gt;) {
<b class="pc">&nbsp;        if (null == on) throw EmptyFieldsException()</b>
<b class="fc">&nbsp;        val tableName = another.kronosTableName()</b>
<b class="fc">&nbsp;        t1.afterFilter {</b>
<b class="fc">&nbsp;            criteriaParamMap = paramMap</b>
<b class="fc">&nbsp;            on(t1)</b>
<b class="fc">&nbsp;            listOfJoinable.add(KJoinable(tableName, JoinType.RIGHT_JOIN, criteria, T::class as KClass&lt;KPojo&gt;, another))</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs a cross join operation between two tables.
&nbsp;     *
&nbsp;     * @param another The table to join with.
&nbsp;     * @param on The condition for the join.
&nbsp;     * @throws EmptyFieldsException If the `on` parameter is null.
&nbsp;     */
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
&nbsp;    inline fun &lt;reified T : KPojo&gt; crossJoin(another: T, noinline on: ToFilter&lt;T1, Boolean?&gt;) {
<b class="nc">&nbsp;        if (null == on) throw EmptyFieldsException()</b>
<b class="nc">&nbsp;        val tableName = another.kronosTableName()</b>
<b class="nc">&nbsp;        t1.afterFilter {</b>
<b class="nc">&nbsp;            criteriaParamMap = paramMap</b>
<b class="nc">&nbsp;            on(t1)</b>
<b class="nc">&nbsp;            listOfJoinable.add(KJoinable(tableName, JoinType.CROSS_JOIN, criteria, T::class as KClass&lt;KPojo&gt;, another))</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs an inner join operation between two tables.
&nbsp;     *
&nbsp;     * @param another The table to join with.
&nbsp;     * @param on The condition for the join.
&nbsp;     * @throws EmptyFieldsException If the `on` parameter is null.
&nbsp;     */
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
&nbsp;    inline fun &lt;reified T : KPojo&gt; innerJoin(another: T, noinline on: ToFilter&lt;T1, Boolean?&gt;) {
<b class="nc">&nbsp;        if (null == on) throw EmptyFieldsException()</b>
<b class="nc">&nbsp;        val tableName = another.kronosTableName()</b>
<b class="nc">&nbsp;        t1.afterFilter {</b>
<b class="nc">&nbsp;            criteriaParamMap = paramMap</b>
<b class="nc">&nbsp;            on(t1)</b>
<b class="nc">&nbsp;            listOfJoinable.add(KJoinable(tableName, JoinType.INNER_JOIN, criteria, T::class as KClass&lt;KPojo&gt;, another))</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs a full join operation between two tables.
&nbsp;     *
&nbsp;     * @param another The table to join with.
&nbsp;     * @param on The condition for the join.
&nbsp;     * @throws EmptyFieldsException If the `on` parameter is null.
&nbsp;     */
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
&nbsp;    inline fun &lt;reified T : KPojo&gt; fullJoin(another: T, noinline on: ToFilter&lt;T1, Boolean?&gt;) {
<b class="pc">&nbsp;        if (null == on) throw EmptyFieldsException()</b>
<b class="fc">&nbsp;        val tableName = another.kronosTableName()</b>
<b class="fc">&nbsp;        t1.afterFilter {</b>
<b class="fc">&nbsp;            criteriaParamMap = paramMap</b>
<b class="fc">&nbsp;            on(t1)</b>
<b class="fc">&nbsp;            listOfJoinable.add(KJoinable(tableName, JoinType.FULL_JOIN, criteria, T::class as KClass&lt;KPojo&gt;, another))</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Selects the specified fields from the table associated with the given KTableField.
&nbsp;     *
&nbsp;     * @param someFields The KTableField representing the fields to be selected.
&nbsp;     */
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
&nbsp;    fun select(someFields: ToSelect&lt;T1, Any?&gt;) {
<b class="pc">&nbsp;        if (null == someFields) return</b>
&nbsp;
<b class="fc">&nbsp;        pojo.afterSelect {</b>
<b class="fc">&nbsp;            someFields(t1)</b>
<b class="pc">&nbsp;            if (fields.isEmpty()) {</b>
<b class="nc">&nbsp;                throw EmptyFieldsException()</b>
&nbsp;            }
<b class="fc">&nbsp;            selectFields += fields</b>
<b class="fc">&nbsp;            fields.forEach { field -&gt;</b>
<b class="fc">&nbsp;                val safeKey = ConditionSqlBuilder.getSafeKey(</b>
<b class="fc">&nbsp;                    field.name,</b>
<b class="fc">&nbsp;                    keyCounters,</b>
<b class="fc">&nbsp;                    selectFieldsWithNames as MutableMap&lt;String, Any?&gt;,</b>
<b class="fc">&nbsp;                    field</b>
&nbsp;                )
<b class="fc">&nbsp;                selectFieldsWithNames[safeKey] = field</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun db(vararg databaseOfTables: Pair&lt;KPojo, String&gt;) {
<b class="fc">&nbsp;        databaseOfTables.forEach {</b>
<b class="fc">&nbsp;            databaseOfTable[it.first.kronosTableName()] = it.second</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    fun cascade(enabled: Boolean) {
<b class="nc">&nbsp;        cascadeEnabled = enabled</b>
&nbsp;    }
&nbsp;
&nbsp;    fun cascade(someFields: ToReference&lt;T1, Any?&gt;) {
<b class="nc">&nbsp;        if (someFields == null) throw EmptyFieldsException()</b>
<b class="nc">&nbsp;        cascadeEnabled = true</b>
<b class="nc">&nbsp;        pojo.afterReference {</b>
<b class="nc">&nbsp;            someFields(t1)</b>
<b class="nc">&nbsp;            if (fields.isEmpty()) throw EmptyFieldsException()</b>
<b class="nc">&nbsp;            cascadeAllowed = fields.toSet()</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Orders the result set by the specified fields.
&nbsp;     *
&nbsp;     * @param someFields The fields to order the result set by.
&nbsp;     * @throws EmptyFieldsException If the `someFields` parameter is null.
&nbsp;     */
&nbsp;    fun orderBy(someFields: ToSort&lt;T1, Any?&gt;) {
<b class="pc">&nbsp;        if (someFields == null) throw EmptyFieldsException()</b>
&nbsp;
<b class="fc">&nbsp;        orderEnabled = true</b>
<b class="fc">&nbsp;        pojo.afterSort {</b>
<b class="fc">&nbsp;            someFields(t1)// 在这里对排序操作进行封装，为后续的链式调用提供支持。</b>
<b class="fc">&nbsp;            orderByFields = sortedFields.toLinkedSet()</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the groupBy flag to true and checks if the `someFields` parameter is null.
&nbsp;     * If it is null, throws a EmptyFieldsException.
&nbsp;     *
&nbsp;     * @param someFields The fields to group the result set by.
&nbsp;     * @throws EmptyFieldsException If the `someFields` parameter is null.
&nbsp;     */
&nbsp;    fun groupBy(someFields: ToSelect&lt;T1, Any?&gt;) {
<b class="nc">&nbsp;        groupEnabled = true</b>
&nbsp;        // 检查 someFields 参数是否为空，如果为空则抛出异常
<b class="nc">&nbsp;        if (null == someFields) throw EmptyFieldsException()</b>
<b class="nc">&nbsp;        pojo.afterSelect {</b>
<b class="nc">&nbsp;            someFields(t1)</b>
<b class="nc">&nbsp;            if (fields.isEmpty()) {</b>
<b class="nc">&nbsp;                throw EmptyFieldsException()</b>
&nbsp;            }
&nbsp;            // 设置分组字段
<b class="nc">&nbsp;            groupByFields = fields.toLinkedSet()</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the distinctEnabled flag to true, indicating that the result set should be distinct.
&nbsp;     */
&nbsp;    fun distinct() {
<b class="nc">&nbsp;        this.distinctEnabled = true</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the limit flag to true and sets the limit capacity to the specified number.
&nbsp;     *
&nbsp;     * @param num the number of records to limit the result set to
&nbsp;     */
&nbsp;    fun limit(num: Int) {
<b class="nc">&nbsp;        this.limitCapacity = num</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the page information for the query, enabling pagination.
&nbsp;     *
&nbsp;     * @param pi the current page number, indicating which page of data to retrieve
&nbsp;     * @param ps the number of records per page, specifying the number of records to display per page
&nbsp;     */
&nbsp;    fun page(pi: Int, ps: Int) {
<b class="fc">&nbsp;        this.pageEnabled = true</b>
<b class="fc">&nbsp;        this.ps = ps</b>
<b class="fc">&nbsp;        this.pi = pi</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Executes the query logic defined in [someFields] and builds the query condition.
&nbsp;     *
&nbsp;     * @param someFields the fields to be queried
&nbsp;     * @throws EmptyFieldsException if [someFields] is null
&nbsp;     */
&nbsp;    fun by(someFields: ToSelect&lt;T1, Any?&gt;) {
&nbsp;        // 检查someFields是否为空，为空则抛出异常
<b class="nc">&nbsp;        if (null == someFields) throw EmptyFieldsException()</b>
<b class="nc">&nbsp;        pojo.afterSelect {</b>
&nbsp;            // 执行someFields中定义的查询逻辑
<b class="nc">&nbsp;            someFields(t1)</b>
<b class="nc">&nbsp;            if (fields.isEmpty()) {</b>
<b class="nc">&nbsp;                throw EmptyFieldsException()</b>
&nbsp;            }
&nbsp;            // 构建查询条件，将字段名映射到参数值，并转换为查询条件对象
<b class="nc">&nbsp;            if (condition == null) {</b>
<b class="nc">&nbsp;                condition = fields.map { it.eq(paramMap[it.name]) }.toCriteria()</b>
&nbsp;            } else {
&nbsp;                // 如果已有条件，则将新条件添加到现有条件中
<b class="nc">&nbsp;                condition!!.children.add(fields.map { it.eq(paramMap[it.name]) }.toCriteria())</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the condition for the query based on the provided select condition.
&nbsp;     *
&nbsp;     * @param selectCondition the conditional field representing the query condition. Defaults to null.
&nbsp;     * If null, a condition is built to query all fields. Otherwise, the provided select condition is executed
&nbsp;     * and the resulting condition is set.
&nbsp;     */
<b class="nc">&nbsp;    fun where(selectCondition: ToFilter&lt;T1, Boolean?&gt; = null) {</b>
<b class="pc">&nbsp;        if (selectCondition == null) {</b>
&nbsp;            // 当没有提供选择条件时，构建一个查询所有字段的条件
<b class="nc">&nbsp;            condition = paramMap.keys.map { propName -&gt;</b>
<b class="nc">&nbsp;                allFields.first { it.name == propName }.eq(paramMap[propName])</b>
<b class="nc">&nbsp;            }.toCriteria()</b>
&nbsp;        } else {
<b class="fc">&nbsp;            pojo.afterFilter {</b>
<b class="fc">&nbsp;                criteriaParamMap = paramMap</b>
<b class="fc">&nbsp;                selectCondition(t1) // 执行用户提供的条件函数</b>
<b class="pc">&nbsp;                if (criteria == null) return@afterFilter</b>
<b class="pc">&nbsp;                if (condition == null) {</b>
<b class="fc">&nbsp;                    condition = criteria // 设置查询条件</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    condition!!.children.addAll(criteria!!.children) // 将新条件添加到现有条件中</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the condition for the HAVING clause based on the provided select condition.
&nbsp;     *
&nbsp;     * @param selectCondition the conditional field representing the HAVING condition. Defaults to null.
&nbsp;     * If null, a condition is built to query all fields. Otherwise, the provided select condition is executed
&nbsp;     * and the resulting condition is set.
&nbsp;     *
&nbsp;     * @throws EmptyFieldsException if the selectCondition parameter is null.
&nbsp;     */
<b class="nc">&nbsp;    fun having(selectCondition: ToFilter&lt;T1, Boolean?&gt; = null) {</b>
&nbsp;        // 检查是否提供了条件，未提供则抛出异常
<b class="nc">&nbsp;        if (selectCondition == null) throw EmptyFieldsException()</b>
<b class="nc">&nbsp;        havingEnabled = true // 标记为HAVING条件</b>
<b class="nc">&nbsp;        pojo.afterFilter {</b>
<b class="nc">&nbsp;            criteriaParamMap = paramMap // 设置属性参数映射</b>
<b class="nc">&nbsp;            selectCondition(t1) // 执行传入的条件函数</b>
<b class="nc">&nbsp;            if (criteria == null) return@afterFilter</b>
<b class="nc">&nbsp;            if (havingCondition == null) {</b>
<b class="nc">&nbsp;                havingCondition = criteria // 如果HAVING条件为空，则直接赋值</b>
&nbsp;            } else {
<b class="nc">&nbsp;                havingCondition!!.children.addAll(criteria!!.children) // 否则将新条件添加到现有HAVING条件中</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    fun patch(vararg pairs: Pair&lt;String, Any?&gt;) {
<b class="nc">&nbsp;        paramMap.putAll(pairs)</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Queries the data source using the provided data source wrapper and returns a list of maps representing the results.
&nbsp;     *
&nbsp;     * @param wrapper the data source wrapper to use for the query. Defaults to null. If null, the default data source wrapper is used.
&nbsp;     * @return a list of maps representing the results of the query.
&nbsp;     */
<b class="nc">&nbsp;    fun query(wrapper: KronosDataSourceWrapper? = null): List&lt;Map&lt;String, Any&gt;&gt; {</b>
<b class="nc">&nbsp;        return this.build().query(wrapper)</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    inline fun &lt;reified T&gt; queryList(</b>
<b class="nc">&nbsp;        wrapper: KronosDataSourceWrapper? = null,</b>
<b class="nc">&nbsp;        isKPojo: Boolean = false,</b>
<b class="nc">&nbsp;        superTypes: List&lt;String&gt; = listOf()</b>
&nbsp;    ): List&lt;T&gt; {
<b class="nc">&nbsp;        return this.build().queryList(wrapper, isKPojo, superTypes)</b>
&nbsp;    }
&nbsp;
&nbsp;    @JvmName(&quot;queryForList&quot;)
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
<b class="nc">&nbsp;    fun queryList(wrapper: KronosDataSourceWrapper? = null): List&lt;T1&gt; {</b>
<b class="nc">&nbsp;        with(this.build()) {</b>
<b class="nc">&nbsp;            beforeQuery?.invoke(this)</b>
<b class="nc">&nbsp;            val result = atomicTask.logAndReturn(</b>
<b class="nc">&nbsp;                wrapper.orDefault().forList(atomicTask, pojo::class, true, listOf()) as List&lt;T1&gt;,</b>
<b class="nc">&nbsp;                QueryType.QueryList</b>
&nbsp;            )
<b class="nc">&nbsp;            afterQuery?.invoke(result, QueryType.QueryList, wrapper.orDefault())</b>
<b class="nc">&nbsp;            return result</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    fun queryMap(wrapper: KronosDataSourceWrapper? = null): Map&lt;String, Any&gt; {</b>
<b class="nc">&nbsp;        limit(1)</b>
<b class="nc">&nbsp;        return this.build().queryMap(wrapper)</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    fun queryMapOrNull(wrapper: KronosDataSourceWrapper? = null): Map&lt;String, Any&gt;? {</b>
<b class="nc">&nbsp;        limit(1)</b>
<b class="nc">&nbsp;        return this.build().queryMapOrNull(wrapper)</b>
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    inline fun &lt;reified T&gt; queryOne(</b>
<b class="nc">&nbsp;        wrapper: KronosDataSourceWrapper? = null,</b>
<b class="nc">&nbsp;        isKPojo: Boolean = false,</b>
<b class="nc">&nbsp;        superTypes: List&lt;String&gt; = listOf()</b>
&nbsp;    ): T {
<b class="nc">&nbsp;        limit(1)</b>
<b class="nc">&nbsp;        return this.build().queryOne(wrapper, isKPojo, superTypes)</b>
&nbsp;    }
&nbsp;
&nbsp;    @JvmName(&quot;queryForObject&quot;)
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
<b class="nc">&nbsp;    fun queryOne(wrapper: KronosDataSourceWrapper? = null): T1 {</b>
<b class="nc">&nbsp;        limit(1)</b>
<b class="nc">&nbsp;        with(this.build()) {</b>
<b class="nc">&nbsp;            beforeQuery?.invoke(this)</b>
<b class="nc">&nbsp;            val result = atomicTask.logAndReturn(</b>
<b class="nc">&nbsp;                (wrapper.orDefault().forObject(atomicTask, pojo::class, true, listOf())</b>
<b class="nc">&nbsp;                    ?: throw NullPointerException(&quot;No such record&quot;)) as T1,</b>
<b class="nc">&nbsp;                QueryType.QueryOne</b>
&nbsp;            )
<b class="nc">&nbsp;            afterQuery?.invoke(result, QueryType.QueryOne, wrapper.orDefault())</b>
<b class="nc">&nbsp;            return result</b>
&nbsp;        }
&nbsp;    }
&nbsp;
<b class="nc">&nbsp;    inline fun &lt;reified T&gt; queryOneOrNull(</b>
<b class="nc">&nbsp;        wrapper: KronosDataSourceWrapper? = null,</b>
<b class="nc">&nbsp;        isKPojo: Boolean = false,</b>
<b class="nc">&nbsp;        superTypes: List&lt;String&gt; = listOf()</b>
&nbsp;    ): T? {
<b class="nc">&nbsp;        limit(1)</b>
<b class="nc">&nbsp;        return this.build().queryOneOrNull(wrapper, isKPojo, superTypes)</b>
&nbsp;    }
&nbsp;
&nbsp;    @JvmName(&quot;queryForObjectOrNull&quot;)
&nbsp;    @Suppress(&quot;UNCHECKED_CAST&quot;)
<b class="nc">&nbsp;    fun queryOneOrNull(wrapper: KronosDataSourceWrapper? = null): T1? {</b>
<b class="nc">&nbsp;        limit(1)</b>
<b class="nc">&nbsp;        with(this.build()) {</b>
<b class="nc">&nbsp;            beforeQuery?.invoke(this)</b>
<b class="nc">&nbsp;            val result = atomicTask.logAndReturn(</b>
<b class="nc">&nbsp;                wrapper.orDefault().forObject(atomicTask, pojo::class, true, listOf()) as T1?,</b>
<b class="nc">&nbsp;                QueryType.QueryOneOrNull</b>
&nbsp;            )
<b class="nc">&nbsp;            afterQuery?.invoke(result, QueryType.QueryOneOrNull, wrapper.orDefault())</b>
<b class="nc">&nbsp;            return result</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds and returns a KronosAtomicQueryTask object based on the provided data source wrapper.
&nbsp;     *
&nbsp;     * @param wrapper the data source wrapper to use for the query. Defaults to null. If null, the default data source wrapper is used.
&nbsp;     * @return a KronosAtomicQueryTask object representing the query.
&nbsp;     */
&nbsp;    override fun build(wrapper: KronosDataSourceWrapper?): KronosQueryTask {
<b class="fc">&nbsp;        var buildCondition = condition</b>
&nbsp;
&nbsp;        // 初始化所有字段集合
&nbsp;
<b class="pc">&nbsp;        if (selectFields.isEmpty()) {</b>
<b class="nc">&nbsp;            selectFields += allFields</b>
&nbsp;        }
&nbsp;
&nbsp;        // 如果条件为空，则根据paramMap构建查询条件
<b class="pc">&nbsp;        if (buildCondition == null) {</b>
<b class="nc">&nbsp;            buildCondition = paramMap.keys.filter {</b>
<b class="nc">&nbsp;                paramMap[it] != null</b>
<b class="nc">&nbsp;            }.mapNotNull { propName -&gt;</b>
<b class="nc">&nbsp;                allFields.firstOrNull { it.name == propName }?.eq(paramMap[propName])</b>
<b class="nc">&nbsp;            }.toCriteria()</b>
&nbsp;        }
&nbsp;
&nbsp;        // 设置逻辑删除的条件
<b class="pc">&nbsp;        logicDeleteStrategy?.execute(defaultValue = getDefaultBoolean(wrapper.orDefault(), false)) { _, value -&gt;</b>
<b class="fc">&nbsp;            buildCondition = listOfNotNull(</b>
<b class="fc">&nbsp;                buildCondition,</b>
<b class="fc">&nbsp;                &quot;${quote(wrapper.orDefault(), logicDeleteStrategy!!.field, true, databaseOfTable)} = $value&quot;.asSql()</b>
<b class="fc">&nbsp;            ).toCriteria()</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        val paramMapNew = mutableMapOf&lt;String, Any?&gt;()</b>
<b class="fc">&nbsp;        val sql = getJoinSql(wrapper.orDefault(), toJoinClauseInfo(wrapper, buildCondition) {</b>
<b class="fc">&nbsp;            paramMapNew.putAll(it.filter { entry -&gt; null != entry.value })</b>
&nbsp;        })
&nbsp;
<b class="fc">&nbsp;        val fieldMap = fieldsMapCache[kClass]!!</b>
<b class="fc">&nbsp;        paramMapNew.forEach { (key, value) -&gt;</b>
<b class="fc">&nbsp;            val field = fieldMap[key]</b>
<b class="pc">&nbsp;            if (field != null &amp;&amp; value != null) {</b>
<b class="fc">&nbsp;                paramMapNew[key] = processParams(wrapper.orDefault(), field, value)</b>
&nbsp;            } else {
<b class="fc">&nbsp;                paramMapNew[key] = value</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        // 返回构建好的KronosAtomicTask对象
<b class="fc">&nbsp;        return CascadeJoinClause.build(</b>
<b class="fc">&nbsp;            cascadeEnabled, cascadeAllowed, listOfPojo, KronosAtomicQueryTask(</b>
<b class="fc">&nbsp;                sql, paramMapNew, operationType = KOperationType.SELECT</b>
<b class="pc">&nbsp;            ), operationType, selectFieldsWithNames, cascadeSelectedProps ?: mutableSetOf()</b>
&nbsp;        )
&nbsp;    }
&nbsp;
&nbsp;    private fun toJoinClauseInfo(
<b class="nc">&nbsp;        wrapper: KronosDataSourceWrapper? = null,</b>
&nbsp;        buildCondition: Criteria?,
&nbsp;        updateMap: (map: MutableMap&lt;String, Any?&gt;) -&gt; Unit
&nbsp;    ): JoinClauseInfo {
<b class="fc">&nbsp;        val (whereClauseSql, mapOfWhere) = buildConditionSqlWithParams(</b>
<b class="fc">&nbsp;            KOperationType.SELECT,</b>
<b class="fc">&nbsp;            wrapper,</b>
<b class="fc">&nbsp;            buildCondition,</b>
<b class="fc">&nbsp;            showTable = true,</b>
<b class="fc">&nbsp;            databaseOfTable = databaseOfTable</b>
<b class="fc">&nbsp;        ).toWhereClause()</b>
&nbsp;
<b class="fc">&nbsp;        val joinSql = &quot; &quot; + listOfJoinable.joinToString(&quot; &quot;) {</b>
<b class="fc">&nbsp;            var joinCondition = it.condition</b>
<b class="fc">&nbsp;            val logicDeleteStrategy = kPojoLogicDeleteCache[it.kClass]</b>
<b class="fc">&nbsp;            logicDeleteStrategy?.execute(defaultValue = getDefaultBoolean(wrapper.orDefault(), false)) { _, value -&gt;</b>
<b class="fc">&nbsp;                joinCondition = listOfNotNull(</b>
<b class="fc">&nbsp;                    joinCondition,</b>
<b class="fc">&nbsp;                    &quot;${</b>
<b class="fc">&nbsp;                        quote(</b>
<b class="fc">&nbsp;                            wrapper.orDefault(),</b>
<b class="fc">&nbsp;                            logicDeleteStrategy.field,</b>
<b class="fc">&nbsp;                            true,</b>
<b class="fc">&nbsp;                            databaseOfTable</b>
&nbsp;                        )
<b class="fc">&nbsp;                    } = $value&quot;.asSql()</b>
<b class="fc">&nbsp;                ).toCriteria()</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            val (onSql, mapOfOn) = buildConditionSqlWithParams(</b>
<b class="fc">&nbsp;                KOperationType.SELECT,</b>
<b class="fc">&nbsp;                wrapper,</b>
<b class="fc">&nbsp;                joinCondition,</b>
<b class="fc">&nbsp;                paramMap,</b>
<b class="fc">&nbsp;                showTable = true,</b>
<b class="fc">&nbsp;                databaseOfTable = databaseOfTable</b>
&nbsp;            )
<b class="fc">&nbsp;                .toOnClause()</b>
<b class="fc">&nbsp;            updateMap(mapOfOn)</b>
&nbsp;
<b class="fc">&nbsp;            it.joinType.value + &quot; &quot; + quote(wrapper.orDefault(), it.tableName, true, map = databaseOfTable) + onSql</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        val groupByClauseSql =</b>
<b class="pc">&nbsp;            if (groupEnabled &amp;&amp; groupByFields.isNotEmpty()) &quot; GROUP BY &quot; + (groupByFields.joinToString(&quot;, &quot;) {</b>
<b class="nc">&nbsp;                quote(wrapper.orDefault(), it, true, databaseOfTable)</b>
<b class="fc">&nbsp;            }) else null</b>
<b class="fc">&nbsp;        val orderByClauseSql =</b>
<b class="pc">&nbsp;            if (orderEnabled &amp;&amp; orderByFields.isNotEmpty()) &quot; ORDER BY &quot; + orderByFields.joinToString(&quot;, &quot;) {</b>
<b class="pc">&nbsp;                if (it.first.type == CUSTOM_CRITERIA_SQL) it.first.toString() else quote(</b>
<b class="fc">&nbsp;                    wrapper.orDefault(),</b>
<b class="fc">&nbsp;                    it.first,</b>
<b class="fc">&nbsp;                    true,</b>
<b class="fc">&nbsp;                    databaseOfTable</b>
<b class="fc">&nbsp;                ) + &quot; &quot; + it.second</b>
<b class="fc">&nbsp;            } else null</b>
<b class="pc">&nbsp;        val (havingClauseSql, mapOfHaving) = if (havingEnabled) buildConditionSqlWithParams(</b>
<b class="nc">&nbsp;            KOperationType.SELECT, wrapper, havingCondition, showTable = true, databaseOfTable = databaseOfTable</b>
<b class="fc">&nbsp;        ).toHavingClause() else null to mutableMapOf()</b>
<b class="fc">&nbsp;        updateMap(mapOfWhere)</b>
<b class="fc">&nbsp;        updateMap(mapOfHaving)</b>
<b class="fc">&nbsp;        return JoinClauseInfo(</b>
<b class="fc">&nbsp;            tableName,</b>
<b class="fc">&nbsp;            selectFieldsWithNames.toList(),</b>
<b class="fc">&nbsp;            distinctEnabled,</b>
<b class="fc">&nbsp;            pageEnabled,</b>
<b class="fc">&nbsp;            pi,</b>
<b class="fc">&nbsp;            ps,</b>
<b class="fc">&nbsp;            limitCapacity,</b>
<b class="fc">&nbsp;            databaseOfTable,</b>
<b class="fc">&nbsp;            whereClauseSql,</b>
<b class="fc">&nbsp;            groupByClauseSql,</b>
<b class="fc">&nbsp;            orderByClauseSql,</b>
<b class="fc">&nbsp;            havingClauseSql,</b>
<b class="fc">&nbsp;            joinSql</b>
&nbsp;        )
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-10-22 15:26</div>
</div>
</body>
</html>
